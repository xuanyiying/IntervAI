/* eslint-disable prettier/prettier */
/**
 * Model Admin Controller
 * Provides API endpoints for managing AI model configurations
 */

import {
  Controller,
  Get,
  Post,
  Put,
  Delete,
  Body,
  Param,
  HttpCode,
  HttpStatus,
  Logger,
  Query,
  BadRequestException,
} from '@nestjs/common';
import { ModelConfigService, ModelConfig } from './config/model-config.service';
import { AIProviderFactory } from './factory/ai-provider.factory';
import { UpsertModelConfigDto } from './dto/upsert-model-config.dto';

/**
 * Model Admin Controller
 * Manages AI model configurations dynamically
 */
@Controller('/admin/models')
export class ModelAdminController {
  private readonly logger = new Logger(ModelAdminController.name);

  constructor(
    private readonly modelConfigService: ModelConfigService,
    private readonly providerFactory: AIProviderFactory
  ) {}

  /**
   * Get all model configurations
   */
  @Get()
  async listModels(
    @Query('provider') provider?: string,
    @Query('isActive') isActive?: string,
    @Query('page') page: string = '1',
    @Query('limit') limit: string = '50'
  ) {
    let configs = await this.modelConfigService.getAllModelConfigs();

    if (provider) {
      configs = await this.modelConfigService.getConfigsByProvider(provider);
    }

    if (isActive !== undefined) {
      const activeFilter = isActive === 'true';
      configs = configs.filter((c) => c.isActive === activeFilter);
    }

    // Pagination
    const pageNum = parseInt(page, 10);
    const limitNum = parseInt(limit, 10);
    const start = (pageNum - 1) * limitNum;
    const end = start + limitNum;

    // Mask API keys in response
    const maskedConfigs = configs.map((config) => ({
      ...config,
      apiKey: this.maskApiKey(config.apiKey),
    }));

    return {
      data: maskedConfigs.slice(start, end),
      total: configs.length,
      page: pageNum,
      limit: limitNum,
      totalPages: Math.ceil(configs.length / limitNum),
    };
  }

  /**
   * Get model configuration by ID
   */
  @Get(':id')
  async getConfig(@Param('id') id: string): Promise<ModelConfig | null> {
    return this.modelConfigService.getModelConfigById(id);
  }

  /**
   * Get configurations by provider
   */
  @Get('provider/:provider')
  async getConfigsByProvider(
    @Param('provider') provider: string
  ): Promise<ModelConfig[]> {
    return this.modelConfigService.getConfigsByProvider(provider);
  }

  /**
   * Create or update model configuration
   */
  @Post()
  async upsertConfig(@Body() dto: UpsertModelConfigDto): Promise<ModelConfig> {
    const clean = (val?: string) => {
      if (!val) return val;
      let s = val.trim();
      while (s.startsWith('`')) s = s.substring(1).trim();
      while (s.endsWith('`')) s = s.substring(0, s.length - 1).trim();
      return s;
    };
    const endpoint = clean(dto.endpoint);
    const apiKey = clean(dto.apiKey) || '';

    const config: ModelConfig = {
      id: '', // Will be generated by database
      name: dto.name,
      provider: dto.provider,
      apiKey: apiKey,
      endpoint: endpoint,
      defaultTemperature: dto.defaultTemperature ?? 0.7,
      defaultMaxTokens: dto.defaultMaxTokens ?? 2000,
      costPerInputToken: dto.costPerInputToken ?? 0,
      costPerOutputToken: dto.costPerOutputToken ?? 0,
      rateLimitPerMinute: dto.rateLimitPerMinute ?? 0,
      rateLimitPerDay: dto.rateLimitPerDay ?? 0,
      isActive: dto.isActive ?? true,
      createdAt: new Date(),
      updatedAt: new Date(),
    };

    const result = await this.modelConfigService.upsertModelConfig(config);

    // Reload providers to apply new configuration
    await this.providerFactory.reloadProviders();

    this.logger.log(`Model configuration upserted: ${dto.name}`);
    return result;
  }

  /**
   * Update model configuration
   */
  @Put(':id')
  async updateConfig(
    @Param('id') id: string,
    @Body() dto: Partial<UpsertModelConfigDto>
  ): Promise<ModelConfig> {
    const existing = await this.modelConfigService.getModelConfigById(id);
    if (!existing) {
      throw new BadRequestException(`Model with ID ${id} not found`);
    }

    // Clean sensitive fields if provided
    const clean = (val?: string) => {
      if (!val) return val;
      let s = val.trim();
      while (s.startsWith('`')) s = s.substring(1).trim();
      while (s.endsWith('`')) s = s.substring(0, s.length - 1).trim();
      return s;
    };

    const updates: Partial<ModelConfig> = { ...dto } as any;
    if (dto.endpoint) updates.endpoint = clean(dto.endpoint);
    if (dto.apiKey) updates.apiKey = clean(dto.apiKey);

    const result = await this.modelConfigService.updateModelConfig(id, updates);
    await this.providerFactory.reloadProviders();
    this.logger.log(`Model configuration updated: ${id}`);
    return result;
  }

  /**
   * Enable model configuration
   */
  @Post(':id/enable')
  @HttpCode(HttpStatus.NO_CONTENT)
  async enableConfig(@Param('id') id: string): Promise<void> {
    await this.modelConfigService.enableModelConfig(id);
    await this.providerFactory.reloadProviders();
    this.logger.log(`Model configuration enabled: ${id}`);
  }

  /**
   * Disable model configuration
   */
  @Post(':id/disable')
  @HttpCode(HttpStatus.NO_CONTENT)
  async disableConfig(@Param('id') id: string): Promise<void> {
    await this.modelConfigService.disableModelConfig(id);
    await this.providerFactory.reloadProviders();
    this.logger.log(`Model configuration disabled: ${id}`);
  }

  /**
   * Delete model configuration
   */
  @Delete(':id')
  @HttpCode(HttpStatus.NO_CONTENT)
  async deleteConfig(@Param('id') id: string): Promise<void> {
    await this.modelConfigService.deleteModelConfig(id);
    await this.providerFactory.reloadProviders();
    this.logger.log(`Model configuration deleted: ${id}`);
  }

  /**
   * Refresh configuration cache
   */
  @Post('refresh')
  @HttpCode(HttpStatus.NO_CONTENT)
  async refreshCache(): Promise<void> {
    await this.modelConfigService.refreshCache();
    await this.providerFactory.reloadProviders();
    this.logger.log('Configuration cache refreshed');
  }

  /**
   * Get provider statuses
   */
  @Get('status/all')
  async getAllProviderStatuses() {
    return this.providerFactory.getAllProviderStatuses();
  }

  /**
   * Get specific provider status
   */
  @Get('status/:provider')
  async getProviderStatus(@Param('provider') provider: string) {
    return this.providerFactory.getProviderStatus(provider);
  }

  /**
   * Trigger health check for a model
   */
  @Post(':id/test')
  async testModel(@Param('id') id: string) {
    const config = await this.modelConfigService.getModelConfigById(id);
    if (!config) {
      throw new BadRequestException(`Model with ID ${id} not found`);
    }
    const isHealthy = await this.providerFactory.checkProviderHealth(
      config.provider
    );
    return {
      id,
      name: config.name,
      provider: config.provider,
      status: isHealthy ? 'valid' : 'error',
      message: isHealthy ? 'Connection successful' : 'Connection failed',
    };
  }

  /**
   * Trigger health check for a provider
   */
  @Post('health-check/:provider')
  async checkProviderHealth(@Param('provider') provider: string) {
    const isHealthy = await this.providerFactory.checkProviderHealth(provider);
    return { provider, isHealthy };
  }

  /**
   * Mask API key for security
   */
  private maskApiKey(apiKey: string): string {
    if (!apiKey || apiKey.length < 8) {
      return '****';
    }
    return `${apiKey.slice(0, 4)}${'*'.repeat(apiKey.length - 8)}${apiKey.slice(-4)}`;
  }
}
